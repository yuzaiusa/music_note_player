# Exercise 3: Adding and removing score lines

In this exercise, we will focus on **class**, member variable, member method, and json.

## Exercise 3a
You have developed a few useful functions to play notes and scores in previous exercises.

You may have noticed a few inconveniences in the way you have been using these functions:
1. You have to start and stop the audio stream every time you play a note or a score.
2. You have to pass the tempo every time you play a score.
3. You have to finish the score in one go. There is no way to build up a score piece by piece and replay later.

It would be nice if you can forget about setting up the audio stream and only set the tempo once.  Also, it would be nice if you can build up your scores by adding pieces to an internal cache or remove the last added piece if you made a mistake. Finally, it would be nice if you can replay the whole internal cache of scores at once.

This is where a class can help. Class can **encapsulat**e the data (**member variables**) and the functions (**member methods**) that operate on the data. Class remembers the state of its member variables and member methods can operate on the member variables without needing to pass them as parameters every time.  For example, Tempo can be a member variable that be memerized once it is set. The audio stream can be a member variable that is set up once when the class instance is created. The internal cache of scores can be a member variable that is initialized when the class instance is created and be modified by member methods to add/remove pieces.

### Task 3.a
Your task is to implement a class `MusicNotePlayer` that does all the things mentioned above.

In the beginning, you will need to implement the class with the following methods:
+ `__init__(self, sample_rate: int = 44100)`: Initialize the player with a sample rate and start the audio stream.
+ `set_tempo(self, tempo: int)`: Set the tempo for playback.
+ `play_note(self, note: str, length: float)`: Set the tempo for playback.
+ `play_score(self, score: str)`: Play a score given as a string.
+ `play_score_file(self, filename: str)`: Play a score from a file.

To properly close the audio stream, some "gargagge collection (GC)" methods need to be implemented.  **This is beyond the scope of this exercise**. Please just **keep the following methods**, don't need to worry about the implementation details:
+ `start(self)`: Start the audio stream.
+ `close(self)`: Stop the audio stream.
+ `__exit__(self)`: Ensure the audio stream is properly closed when the instance is gone.

The next step is to allow adding and removing scores. The internal cache will be a list of scores (strings).  The cache should be initialized in __init__ and should be empty at the start. Implement the following methods:
+ `add_score(self, score: str)`: Add a score to the internal cache for later playback.
+ `add_score_file(self, filename: str)`: Add a score from a file to the internal cache.
+ `undo_add_score(self)`: Remove the last added score from the internal cache.
+ `get_scores(self) -> str`: Get the current internal cache of scores as a string.
+ `replay(self)`: Replay the whole internal cache of scores.
+ `reset(self)`: Clear the internal cache of scores.

### Tip 3.a
Once you have implemented the class, test its functionality one by one. It would be easier if you tried it in a jupyter notebook. To use this class in a jupyter notebook, you need to import:
```
    from exercise3a import MusicNotePlayer
```
Eventually, you can play with it in your jupyter notebook or here like this:
```
    filename = "sample_score.txt"
    with MusicNotePlayer(tempo=60) as p:
        p.play_score_file(filename)
```
Or, you can play with adding/removing scores like this:
```
    with MusicNotePlayer(tempo=60) as p:
        p.add_score("A4/0.25,B4/0.25,C5/0.75,B4/0.25,C5/0.5,E5/0.5,B4/1.5")
        p.replay()
        p.add_score("A4/0.25,B4/0.25,C5/0.75,B4/0.25,C5/0.5,E5/0.5,B4/1.5,E4/0.5,A4/0.75,G4/0.25,A4/0.5,C5/0.5,G4/1.5,E4/0.5,F4/0.5,C5/0.25,B4/0.75,C5/0.5,D5/0.5,E5/0.25,C5/1.25,C5/0.375,B4/0.375,A4/1,B4/1,G#4/1,A4/4")
        p.replay()
        print(p.get_scores())
        p.undo_add_score()
        p.replay()
        p.reset()
        p.replay()
```

## Exercise 3b
Class `MusicNotePlayer` cannot save its results easily. Python classes usually don't have a universal save/load function.  (It can be done with pickle, but it's not platform independent and not very user friendly.)

To save/load in a platform independent and user friendly way, we can use json files. Json files are text files that can be easily read and written by humans. They can also be easily parsed and generated by machines. Json files can represent basic data structures such as strings, numbers, lists, and dictionaries.

### Task 3.b
In thise exercise, please derive a new class called `MusicNotePlayerWithSave` from `MusicNotePlayer`. You need to add two methods:
+ `to_json(self) -> str`: Convert the internal state of the class object to a json string.
+ `from_json(self, json_str: str)`: Set the internal state of the class object from a json string.

### Tip 3.b
Tips:
1. json dump a dict to a str or a file. To dump to a file, use json.dump. To dump to a str, use json.dumps.
2. json load a dict from a str or a file. To load from a file, use json.load.
3. json dump and load deals with files opened in text mode. It takes in a file object instead of a file name.  So, the typical usage is like:
```
    with open(filename, "r") as json_file:
        json.load(json_file)
```
or, to dump:
```
    with open(filename, "w") as json_file:
        json.dump(my_dict_to_be_dumped, json_file)
```
